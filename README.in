
# zrand.h

`zrand.h` is a high-performance, cross-platform Random Number Generator (RNG) library for C and C++. It implements the **PCG-XSH-RR** algorithm, which offers statistically superior randomness compared to the standard `rand()` (Linear Congruential Generator) while remaining extremely fast and memory-efficient.

It also includes a robust **C++11 wrapper** (`z_rand` namespace) that integrates with STL containers and provides a modern, fluent API.

## Features

* **Statistically Robust**: Uses the PCG algorithm (Permuted Congruential Generator). Passes rigorous statistical tests (TestU01/BigCrush) where standard `rand()` fails.
* **Bias-Free Ranges**: Implements rejection sampling for `zrand_range()`, eliminating the "modulo bias" inherent in `rand() % N`.
* **Cross-Platform Entropy**: Automatically seeds from the OS CSPRNG (`/dev/urandom` on Linux/macOS, `rand_s` on Windows).
* **Thread Safety**: Uses thread-local state by default. No locks required for global generation.
* **Deterministic Mode**: Supports explicit seed/sequence initialization for replay systems or procedural generation.
* **Gaussian Distribution**: Built-in Box-Muller transform for normal distributions.
* **Zero Dependencies**: Standard C headers only. Can optionally use `zmath.h` for math functions to avoid linking `-lm`, or falls back to `<math.h>`.
* **Header Only**: No linking required.

## Installation

1.  Copy `zrand.h` to your project's include folder.
2.  In exactly **one** source file (`.c` or `.cpp`), define the implementation macro `ZRAND_IMPLEMENTATION` before including the header.

```c
#define ZRAND_IMPLEMENTATION
#include "zrand.h"
```

### Optional: zmath.h Integration

If you want to avoid linking against the standard math library (`-lm`) or want a strictly freestanding environment, you can use **zmath.h**.
The provided `Makefile` handles this automatically for testing:

```bash
# For running the tests. Will get and remove 'zmath.h'.
make test

# Or if you just want to get 'zmath.h'.
make
```

## Usage: C

For C projects, you can use the global API for immediate results without managing state. The library handles seeding automatically.

```c 
#define ZRAND_IMPLEMENTATION
#define ZRAND_SHORT_NAMES
#include "zrand.h"
#include <stdio.h>

int main(void)
{
    // Auto-seeds from OS entropy on first use. No srand() needed.
    
    // Basic generation.
    printf("d20 Roll: %d\n", rand_range(1, 20));
    printf("Float (0..1): %.4f\n", rand_f32());

    // Utilities.
    if (rand_chance(0.05)) 
    {
        printf("Critical Hit! (5%% chance)\n");
    }

    // Gaussian (mormal) distribution (Mean=0, StdDev=1).
    printf("Normal Value: %.4f\n", rand_gaussian(0.0, 1.0));

    // UUID generation.
    char uuid[37];
    rand_uuid(uuid);
    printf("New ID: %s\n", uuid);

    return 0;
}
```

**Note:** You can use `#define ZRAND_SHORT_NAMES` to access functions as `rand_xyz` instead of `zrand_xyz`.

## Usage: C++

The library detects C++ automatically. The wrapper lives in the **`z_rand`** namespace.

```cpp
#include <iostream>
#include <vector>
#include "zrand.h"

int main()
{
    // A native-like API.
    std::cout << "d6 Roll: " << z_rand::range(1, 6) << "\n";
    std::cout << "UUID: " << z_rand::uuid() << "\n"; // Returns std::string.

    // STL integration.
    std::vector<int> deck = {1, 2, 3, 4, 5};
    z_rand::shuffle(deck); // Works directly on std::vector.

    // Deterministic Instance.
    z_rand::generator rng(12345); // Fixed seed.
    std::cout << "Replay Value: " << rng.range(1, 100) << "\n";

    return 0;
}
```

[//]: # (ZDOC_START)
[//]: # (ZDOC_END)

## Why PCG?

The default `rand()` in C is typically a Linear Congruential Generator (LCG). LCGs have statistical flaws:
1.  **Short Periods**: They repeat sequences relatively quickly.
2.  **Poor Distribution**: They can fail basic statistical tests (like the "Birthday Spacings" test).
3.  **Low Bits**: The lower bits of an LCG often exhibit visible patterns (odd/even/odd/even).

**PCG (Permuted Congruential Generator)** solves this by applying a permutation function (XSH-RR) to the output of an LCG. This scrambles the bits, resulting in:
* Excellent statistical quality (passes BigCrush).
* Performance that is often **faster** than `rand()` due to modern CPU optimizations.
* A huge period (2^64), making repeats virtually impossible in typical applications.
